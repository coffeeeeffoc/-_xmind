# 浏览器

## 浏览器多进程

### Browser进程：

- 浏览器的主进程（负责协调、主控），只有一个

	- 作用

		- 负责浏览器界面显示，与用户交互。如前进，后退等
		- 负责各个页面的管理，创建和销毁其他进程
		- 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
		- 网络资源的管理，下载等

### 第三方插件进程

- 每种类型的插件对应一个进程，仅当使用该插件时才创建

### GPU进程

- 最多一个，用于3D绘制等

### 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）

- 默认每个Tab页面一个进程，互不影响

	- 页面渲染，脚本执行，事件处理等

- 内核的线程

	- GUI渲染线程

		- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
		- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
		- 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

	- JS引擎线程

		- 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
		- JS引擎线程负责解析Javascript脚本，运行代码。
		- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
		- 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

	- 事件触发线程

		- 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
		- 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
		- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
		- 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

	- 定时触发器线程

		- 传说中的setInterval与setTimeout所在线程
		- 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
		- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
		- 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
异步http请求线程
	- 

		- 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
		- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

- WebWorker

	- 与SharedWorker关系

		- WebWorker只属于某一个tab页，，不会和其他进程共享
		- SharedWorker是浏览器所有页面共享的，是由一个独立的进程管理

	- 特点

		- 通过postMessage API通信，通过序列化对象来与线程交互数据
		- 不能操作DOM
		- 为了解决大计算量问题

## 多进程优势

### 避免单个

### 避免单个page crash影响整个浏览器

### 避免第三方插件crash影响整个浏览器

### 多进程充分利用多核优势

### 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

## 浏览器渲染

### 浏览器渲染流程

- 前期工作

	- 
	- 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程
	- - 浏览器渲染流程开始

- 渲染

	- 解析html建立dom树
	- 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）
	- 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
	- 绘制render树（paint），绘制页面像素信息
	- 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。

- 

### css加载

- css由单独的下载线程异步下载
- css加载不会阻塞DOM解析
- css加载会阻塞render树渲染（因为由上图可知renderTree依赖styleTree）

### 普通图层、复合图层

- 普通图层
- 复合图层

	- 默认复合图层

		- 普通文档流
		- absolute布局

	- 新的复合图层

		- 通过硬件加速的方式、声明一个新的复合图层

			- 最常用的方式：translate3d、translateZ
			- opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
			- will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）
			- <video><iframe><canvas><webgl>等元素
			- 其它，譬如以前的flash插件

- absolute和硬件加速的区别

	- absolute虽然可以脱离普通文档流，但是无法脱离默认复合层

- 复合图层的作用

	- 独立于普通文档流，改动后可以避免整个页面重绘，提升性能

- 注意事项

	- 避免大量使用复合图层，否则资源消耗多度，页面变卡
	- 硬件加速，尽量使用index层级

### load和DOMContentLoaded

- DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。

	- (譬如如果有async加载的脚本就不一定完成)

- onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。

	- （渲染完毕了）

## 事件循环机制

### 事件循环

### 为什么用setTimeout模拟setInterval

- setInterval有两个缺点：

	- 使用setInterval时，某些间隔会被跳过；
	- 可能多个定时器会连续执行

- 模拟

	- setTimeout(function () {
    // 任务
    setTimeout(arguments.callee, interval);
}, interval)
	- 优点

		- 在前一个定时器执行完前，不会向队列插入新的定时器（解决缺点一）
		- 保证定时器间隔（解决缺点二）

### macrotask与microtask

## 参考链接

### https://segmentfault.com/a/1190000012925872?utm_source=tag-newest#articleHeader3

