# 前端性能优化

## 雅虎35条军规

### 尽量减少 HTTP 请求个数——须权衡

### 使用 CDN（内容分发网络）

### 为文件头指定 Expires 或 Cache-Control ，使内容具有缓存性。

### 避免空的 src 和 href

### 使用 gzip 压缩内容

### 把 CSS 放到顶部

### 把 JS 放到底部

### 避免使用 CSS 表达式

### 将 CSS 和 JS 放到外部文件中

### 减少 DNS 查找次数

### 精简 CSS 和 JS

### 避免跳转

### 剔除重复的 JS 和 CSS

### 配置 ETags

### 使 AJAX 可缓存

### 尽早刷新输出缓冲

### 使用 GET 来完成 AJAX 请求

### 延迟加载

### 预加载

### 减少 DOM 元素个数

### 根据域名划分页面内容

### 尽量减少 iframe 的个数

### 避免 404

### 减少 Cookie 的大小

### 使用无 cookie 的域

### 减少 DOM 访问

### 开发智能事件处理程序

### 用  代替 @import

### 避免使用滤镜

### 优化图像

### 优化 CSS Spirite

### 不要在 HTML 中缩放图像——须权衡

### favicon.ico要小而且可缓存

### 保持单个内容小于25K

### 打包组件成复合文本

### 作者：子木_lsy

### 链接：https://juejin.im/post/5b0bff30f265da08f76cc6f0

### 来源：掘金

### 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 减少请求数量

### 合并文件

### 图片处理

- 雪碧图
- base64
- 字体图标代替图片

### 减少重定向

- 会延迟整个HTML文档的传输
- 如果一定要使用重定向，尽量使用永久重定向301，而不是临时重定向302

### 使用缓存

- 使用cach-control或expires这类强缓存时，缓存不过期的情况下，不向服务器发送请求。强缓存过期时，会使用last-modified或etag这类协商缓存，向服务器发送请求，如果资源没有变化，则服务器返回304响应，浏览器继续从本地缓存加载资源；如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回200响应

### 不适用css的@import

- CSS的@import会造成额外的请求

### 避免使用空的src和href

- a标签设置空的href，会重定向到当前的页面地址

form设置空的method，会提交表单到当前的页面地址

## 减少资源大小

### 压缩

### 开启gzip

- HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术

## 优化网络连接

### 使用CDN

- CDN全称是Content Delivery Network，即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度

### 使用DNS预解析

- 当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址

　　DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度

　　方法是在 head 标签里面写上几个 link 标签

<link rel="dns-prefecth" href="https://www.google.com">
<link rel="dns-prefecth" href="https://www.google-analytics.com">
　　对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间

### 并行连接

- 在HTTP1.1协议下，chrome每个域名的最大并发数是6个。使用多个域名，可以增加并发数

### 持久连接

- 使用keep-alive或presistent来建立持久连接，持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量

### 管道化连接

- 在HTTP2协议中，可以开启管道化连接，即单条连接的多路复用，每条连接中并发传输多个资源，这里就不需要添加域名来增加并发数了

## 优化资源加载

### 资源加载位置

- 通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用

　　1、CSS文件放在head中，先外链，后本页

　　2、JS文件放在body底部，先外链，后本页

　　3、处理页面、处理页面布局的JS文件放在head中，如babel-polyfill.js文件、flexible.js文件

　　4、body中间尽量不写style标签和script标签

### 资源加载时机

- 异步script标签

	- defer:  异步加载，在HTML解析完成后执行。实际效果与将代码放在body底部类似
	- async: 异步加载，加载完成后立即执行

- 模块按需加载

	- webpack

		- import()
		- require.ensure()

- 资源预加载preload和资源预读取prefetch

	- preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度
	- prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度

- 资源懒加载与资源预加载

	- 资源延迟加载也称为懒加载，延迟加载资源或符合某些条件时才加载某些资源
	- 源预加载是提前加载用户所需的资源，保证良好的用户体验
	- 资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不做操作，浏览器空间时，再加载资源，优化了网络性能

### 减少重绘回流

- 样式设置

	- 避免使用层级较深的选择器，或其他一些复杂的选择器，以提高CSS渲染效率
	- 避免使用CSS表达式，CSS表达式是动态设置CSS属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次
	- 元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流
	- 给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从0到完全出现，上下左右都可能位移，发生回流
	- 能够使用CSS实现的效果，尽量使用CSS而不使用JS实现
	- 不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间

- 渲染层

	- 对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流
	- 将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围

### DOM优化

- 缓存DOM
- 减少DOM深度及DOM数量
- 批量操作DOM

	- 先用字符串拼接完毕，再用innerHTML更新DOM

- 批量操作CSS样式

	- 通过切换class或者使用元素的style.csstext属性去批量操作元素样式

- 在内存中操作DOM

	- 使用DocumentFragment对象，让DOM操作发生在内存中，而不是页面上

- DOM元素离线更新

	- 可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作

- DOM读写分离

	- 浏览器具有惰性渲染机制，连接多次修改DOM可能只触发浏览器的一次渲染。而如果修改DOM后，立即读取DOM。为了保证读取到正确的DOM值，会触发浏览器的一次渲染。因此，修改DOM的操作要与访问DOM分开进行

- 事件代理

	- 事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件
	- 利用事件代理，可以减少内存使用，提高性能及降低代码复杂度

- 防抖和节流

	- 限制某一个方法的频繁触发
	- 节流

		- 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

	- 防抖

		- 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

- 及时清理环境

	- 及时消除对象引用，清除定时器，清除事件监听器，创建最小作用域变量，可以及时回收内存

### 性能更好的API

- 用对选择器

	- 选择器的性能排序

		- id选择器（#myid）
类选择器（.myclassname）
标签选择器（div,h1,p）
相邻选择器（h1+p）
一般兄弟选择器（h1~p）
子选择器（ul > li）
后代选择器（li a）
通配符选择器（*）
属性选择器（a[rel="external"]）
伪类选择器（a:hover,li:nth-child）

- 使用requestAnimationFrame来替代setTimeout和setInterval

	- 希望在每一帧刚开始的时候对页面进行更改，目前只有使用 requestAnimationFrame 能够保证这一点。使用 setTimeout 或者 setInterval 来触发更新页面的函数，该函数可能在一帧的中间或者结束的时间点上调用，进而导致该帧后面需要进行的事情没有完成，引发丢帧

- 使用IntersectionObserver来实现图片可视区域的懒加载

	- 传统的做法中，需要使用scroll事件，并调用getBoundingClientRect方法，来实现可视区域的判断，即使使用了函数节流，也会造成页面回流。使用IntersectionObserver，则没有上述问题

- web worker

	- Web Worker是HTML5提供的一个javascript多线程解决方案，可以将一些大计算量的代码交由web Worker运行，从而避免阻塞用户界面，在执行复杂计算和数据处理时，这个API非常有用

### webpack优化

- 打包公共代码
- 动态导入和按需加载
- 剔除无用代码

	- tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup
	- JS的tree shaking主要通过uglifyjs插件来完成，CSS的tree shaking主要通过purify CSS来实现的

- 长缓存优化

	- 将hash替换为chunkhash，这样当chunk不变时，缓存依然有效

- 公用代码内联

	- 　　使用html-webpack-inline-chunk-plugin插件将

